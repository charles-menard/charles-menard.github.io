<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 
  <title>IFT3150 - Charles Ménard</title>
</head>


<body>
  <h1>Prévision de demande d'électricité à l'aide de moindres carrés non-linéaires sous contrainte </h1>
  <br>
  <br>
  <h2>Pour le cours IFT3150 - Charles Ménard</h2>
  <br>
  <hr/>
  <h2>Menu</h2>
  <a href="#enonce">Énoncé du projet</a><br>
  <a href="#description">Description détaillée</a><br>
  <a href="#plan">Plan de développement</a><br>
  <a href="#avancement">Avancement</a><br>
  <a href="#coordonnees">Coordonnées</a><br>

<hr>
  <div id="enonce"><h2>Énoncé du projet</h2>
  
  <p>
    La prévision de la demande en électricité est une question complexe mais cruciale pour opérer les réseaux de fourniture électrique et les centrales de progression, ce d’autant que l’électricité, une fois produite, est une commodité qui doit être consommée immédiatement. Nous nous intéressons dans le cadre du présent projet à la prédiction de le demande à court terme, c’est-à-dire dans un horizon de 4 à 24 heures, ce qui représente le cadre opérationnel de l’équipe de prédiction court terme d’Hydro-Québec Transénergie (HQT). Les modèles mis au point par HQT sont divers et sont en cours de réévaluation suite aux profonds changements qui s’opèrent actuellement dans les profils de consommation, reflétant l’évolution de la société en général. Les modèles actuellement en production reposent principalement sur des approches de régression non-linéaires, et sur plusieurs librairies qui, bien qu’éprouvées, posent des problèmes de maintenance à long terme en raison des langages dans lesquels elles sont implémentées. Alors qu’HQT développent ses nouveaux outils principalement en Python et en Julia, l’intégration de ces outils est de plus en plus délicate et coûteuse, tout en rendant délicat l’intégration des derniers développements en optimisation non-linéaire et en apprentissage automatique.</p>
  <p>
    Le but de ce projet est d’étudier une des librairies employées par HQT, qui implémentaire un algorithme de moindres carrés non-linéaires sous contraintes.
  </p>
  </div>
<hr/>
  <div id="description"><h2>Description détaillée</h2>

  <p>
    La librairie qui sera étudiée est ENLSIP, qui est implantée en FORTRAN77. Dans un premier temps, le code sera réimplanté en Julia et testé sur des données fournies par HQT. Dans un deuxième temps, des améliorations potentielles seront examinées pour l’algorithme, sur base de travaux récents menés en parallèles par d’autres étudiants. Deux pistes en particulier s’annoncent prometteuses, à savoir l’approximation rétrospective, consistant à sous-échantillonner les observations au cours des premières itérations de l’algorithme, et les approches quasi-Newton sans stockage de matrices, sur base des approches de type Gauss-Newton. Ces deux méthodes peuvent également être combinées pour traiter des jeux de données de très grande taille dans des temps de calcul raisonnable, défi important pour HQT comme les données sont acquises de manière de plus en plus fine, notamment grâce aux compteurs intelligents.</p>
  </div>
		
	
<hr/>
  <div id="plan"><h2> Plan de développement </h2>
		<b>Date de début : </b>6 janvier 2020 <br>
		<b>Date de fin : </b>25 avril 2020<br>
    	<p>
      <b>Plan pour le mois de Janvier : </b>Me familiariser avec l'algorithme de Gauss-Newton
	    et traduire le code du fichier <code>dblreduns.f</code> </p>
	  <p>	
	  <b>Plan pour le mois de Février : </b>Terminer de traduire le fichier <code>dblreduns.f</code>
	  et être bien avancé dans les tests pour m'assurer du bon fonctionnement du code.
	<b>Plan pour le mois de Mars : </b>Terminer de traduire le code et m'assurer que les scripts Julia,
fonctionne minimalement.
		  <b>Plan pour le mois d'avril : </b>Terminer de traduire le code et le faire fonctionner sur
un problème de moindre carré.
		
		</div>
<hr/>
<div id="avancement"><h2> Avancement </h2>
  <h2><a href="https://github.com/charles-menard/nlcls">Lien vers le code</a>
  </h2>
		<h3>Semaine du 6 au 12 janvier</h3>
		  <p>
		    J'ai commencé par faire le site web du projet. Ensuite, j'ai lu l'article de Lindstrom et Wedin décrivant l'algorithme de Gauss-Newton avec contrainte, qui est utilisé dans ENLSIP. De plus, n'ayant jamais lu de code FORTRAN, j'ai lu une brève introductions au langage.
		  </p>
		  <h3>Semaine du 13 au 19 janvier</h3>
		  
  <p> J'ai continué ma lecture du code, ce qui est plus difficile que je l'avais prévu car les identificateurs 
	  ne sont pas très informatifs et comme le code est en FORTRAN77, certaines pratiques de programmations me sont obscures.
	  J'ai commencé à traduire des fonctions du fichier <code>dblreduns.f</code>.</p>
    <h3>Semaine du 20 au 26 janvier</h3>
    
  <p>J'ai continué à traduire du code du fichier <code>dblreduns.f</code>. Aussi, j'ai lu une portion d'un autre livre sur l'algorithme de Gauss-Newton (cas non-contraint) pour améliorer ma compréhension de l'algorithme. Enfin, je pense à des façons de tester le code que je vais écrire pour m'assurer de sa qualité.</p>
	<h3>Semaines du 27 janvier  au 9 février</h3>
    
  <p> Toujours à traduire le code de <code>dblreduns.f</code>, qui est plus long que prévu, le fichier ayant
	  plus de 5000 lignes de code. J'essaie de donner des noms plus significatifs aux paramètres des fonctions, très nombreux
	  mais cela fait que je dois me rappeler la correspondance entre les noms de la version FORTRAN et Julia. Souvent,
	  je me questionne sur la balance entre seulement transposer le code en Julia, ce qui est plus rapide, et rendre le code
	  plus lisible. Afin de mener le projet à terme, je me contente de faire les modifications faciles pour améliorer
	  un peu la lisibilité du code.
	  
	  </p>
	<h3>Semaine du 10 au 16 février</h3>
    
  <p> Encore à traduire le code de <code>dblreduns.f</code>, mais la cadence augmente car je suis plus habitué au code et
	  je suis plus familié avec les noms des paramètres des fonctions et leur rôles. Je n'ai toujours pas commencé
	  à écrire des tests, mais je compte commencer sous peu, voulant tout d'abord avoir fait un bon bout de chemin
	  dans la traduction du code.
	  
	  </p>
		<h3>Semaines du 17 février au 1 mars </h3>
    
  <p> Je n'ai pas encore fini le travail sur le fichier <code>dblreduns.f</code>, il reste quelques centaines
lignes de code plus les tests. J'ai eu quelques petits problèmes, le plus grand étant :
j'avais oublié que les paramètres scalaires en Julia ne sont pas passés par référence contrairement à FORTRAN,
donc les fonctions qui en FORTRAN modifiaient les paramètres scalaires ne les modifiaient plus en Julia. J'ai réglé
le problème en faisant un type "wrapper" pour les Float et les Int. Aussi, il y une ou deux grosses sous-routines qui
avaient beaucoup de goto en spaghetti, ce qui rend difficile la compréhension de l'exécution du code.
	  
	  </p>
	<h3>Semaines du 2 mars au 15 mars</h3>
	<p>
	J'ai terminé de traduire le fichier <code>dblreduns.f</code> le 10 mars. Il me restait à réviser certaines
parties du code pour intégrer les changements que j'ai mentionné au semaine précédente : par exemple, je devais m'assurer
que toutes les variables de type "int" ou "float64" qui était modifiées par une sous-routine était bien de type
"wrapper", ce qui demandait de modifier certaines anciennes fonctions et les appels à ces fonctions. 

	</p>
	<h3>Semaines du 16 mars au 30 mars</h3>
	<p>
	J'ai réglé certains problèmes dans le fichier <code>dblreduns.f</code>. Par exemple, je me suis rendu compte
qu'en Julia, bien que les tableaux soient passés par référence, les sous-tableaux sont passés par copie. J'ai donc
dû consulter la documentation de Julia pour voir que je devais utiliser l'interface "view" pour obtenir le résultat 
désiré.
	</p>
	<p>
	De plus, j'ai commencé à travailler sur le fichier <code>dblmod2nls.f</code>. Celui-ci contient la majorité
du code restant à traduire. Mon travail s'est accéléré car je suis davantage familier avec le nom des paramètres
et les idiomes Fortran.
	</p>
	<h3>31 mars au 27 avril</h3>
	<p>
	Le code de <code>dblmod2nls.f</code> ainsi que de <code>dblwrkset.f</code> est traduit depuis une semaine ou deux.
		Le fichier <code>dblenls.f</code> consiste en une version plus facile a appeler de la routine principale 
		de moindre carrée (la routine est dans <code>dblmod2nls.f</code> et s'appelle <code>nlsnip</code>).
		J'ai créé une routine similaire pour pouvoir appeler facilement la routine de moindre carrée,
		avec des paramètres par défaut.
		
	</p>
	<p> Avant de pouvoir faire "rouler" le code sans message d'erreur, j'ai du corriger de nombreuses erreurs que 
		j'avais introduit dans le code, en majorité des erreurs dans les appels de fonctions, en raison du
		grand nombre de paramètres. J'ai également eu des problèmes mettant en cause l'ancienne pratique d'utiliser
		un seul gros tableau pour tous les calculs intermédiaires, pour économiser de la mémoire. Pour un tableau
		X, une routine peut s'attendre à ce que X soit un tableau de 10 élements, et une autre un tableau de 20 élements.
		En date du 27 avril, le code "tourne mais donne des résultats erronnés.
		</p>	
	</div>
<hr/>
		<div id="coordonnees">
		  <h2>Coordonnées</h2>
		  <b>Charles Ménard : </b>charles.menard.1 at umontreal.ca <br>
		  <b>Superviseur : </b> Fabian Bastin, DIRO, bastin at iro.umontreal.ca <br>
		</div>
		
		

<!--	</td>
</tr>
-->

<!-- </table> -->



</body>
</html>



